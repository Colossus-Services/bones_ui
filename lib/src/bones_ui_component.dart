import 'dart:async';
import 'dart:collection';

import 'package:collection/collection.dart'
    show IterableExtension, equalsIgnoreAsciiCase;
import 'package:dom_builder/dom_builder.dart';
import 'package:dom_tools/dom_tools.dart';
import 'package:dynamic_call/dynamic_call.dart';
import 'package:statistics/statistics.dart'
    show Decimal, DynamicInt, DynamicNumber;
import 'package:swiss_knife/swiss_knife.dart';
import 'package:web_utils/web_utils.dart';

import 'bones_ui_async_content.dart';
import 'bones_ui_base.dart';
import 'bones_ui_content.dart';
import 'bones_ui_extension.dart';
import 'bones_ui_generator.dart';
import 'bones_ui_internal.dart';
import 'bones_ui_layout.dart';
import 'bones_ui_log.dart';
import 'bones_ui_navigator.dart';
import 'bones_ui_root.dart';
import 'bones_ui_utils.dart';
import 'bones_ui_web.dart';
import 'component/input_config.dart';
import 'component/json_render.dart';

/// [UIComponent] behavior to clear the component.
enum UIComponentClearParent { onConstruct, onInitialRender, onRender }

/// Base class to create `Bones_UI` components.
abstract class UIComponent extends UIEventHandler {
  /// The [UIDOMGenerator] used by `Bones_UI`.
  static final UIDOMGenerator domGenerator = UIDOMGenerator();

  /// The [DOMContext] of the [domGenerator].
  static DOMContext<UINode> get domContext => domGenerator.domContext!;

  /// Register a [generator] for a type of [UIComponent].
  static bool registerGenerator(UIComponentGenerator generator) {
    return domGenerator.registerElementGenerator(generator);
  }

  DOMTreeMap<UINode>? _domTreeMap;

  /// [DOMTreeMap] for this component (lazily-created).
  ///
  /// Maps [DOMNode]s and [UINode]s in the DOM tree generated by [domGenerator].
  /// Also handles event subscriptions and purging (see [DOMTreeMap.purge]).
  DOMTreeMap<UINode> get domTreeMap => _domTreeMap ??= DOMTreeMap(domGenerator)
    ..setRoot(ExternalElementNode(this), content);

  /// Returns the [DOMTreeMap] if it has already been initialized.
  ///
  /// Unlike [domTreeMap], this getter does not create a new instance and
  /// returns `null` if [domTreeMap] has not been accessed yet.
  DOMTreeMap<UINode>? get domTreeMapIfInitialized => _domTreeMap;

  /// Global dummy [DOMTreeMap] instance.
  ///
  /// Used when a non-null [DOMTreeMap] is required but no real DOM
  /// mapping or event handling is needed.
  static final DOMTreeMap<UINode> domTreeMapDummy =
      DOMTreeMapDummy(domGenerator);

  final UIComponentGenerator? _generator;

  static int _globalIDCount = 0;

  final int globalID;

  dynamic id;

  UIComponent? _parentUIComponent;

  UIElement? _parent;
  final UIComponentClearParent? clearParent;

  HTMLElement? _content;

  bool? _constructing;

  bool? get constructing => _constructing;

  final bool _subComponent;

  UIComponent._(Object? parent,
      {bool subComponent = false,
      UIComponent? parentComponent,
      dynamic componentClass,
      dynamic componentStyle,
      dynamic classes,
      dynamic classes2,
      dynamic style,
      dynamic style2,
      this.clearParent,
      bool inline = true,
      bool construct = true,
      bool renderOnConstruction = false,
      bool preserveRender = false,
      this.id,
      UIComponentGenerator? generator})
      : globalID = ++_globalIDCount,
        _subComponent = subComponent,
        _generator = generator {
    if (subComponent) {
      _domTreeMap = parentComponent?.domTreeMap;
    }

    _resolveParent(parent);

    if (construct) {
      _construct(preserveRender, inline, classes, classes2, componentClass,
          style, style2, componentStyle, renderOnConstruction);
    }
  }

  /// Creates a UI component.
  ///
  /// The optional [parent] is the DOM target or logical container where the
  /// component will be inserted. If null, it will be defined by the component
  /// that encapsulates this one during render.
  ///
  /// Rendering behavior:
  /// * [construct] builds the element immediately.
  /// * [renderOnConstruction] renders right after construction.
  /// * [preserveRender] preserves previously rendered elements in future renders.
  /// * [inline] creates the [content] element as inline.
  ///
  /// Styling:
  /// * [componentClass] / [componentStyle] default values applied to the
  ///   [content] element.
  /// * [classes] / [classes2] are merged CSS classes.
  /// * [style] / [style2] are merged style declarations.
  ///
  /// Structure control:
  /// * [clearParent] optionally clears the container before insertion.
  /// * [generator] the [UIComponentGenerator] used to generate [DOMNode] elements.
  /// * [id] the ID of the component instance (not applied to the [content] element).
  UIComponent(
    Object? parent, {
    dynamic componentClass,
    dynamic componentStyle,
    dynamic classes,
    dynamic classes2,
    dynamic style,
    dynamic style2,
    UIComponentClearParent? clearParent,
    bool inline = true,
    bool construct = true,
    bool renderOnConstruction = false,
    bool preserveRender = false,
    dynamic id,
    UIComponentGenerator? generator,
  }) : this._(
          parent,
          componentClass: componentClass,
          componentStyle: componentStyle,
          classes: classes,
          classes2: classes2,
          style: style,
          style2: style2,
          clearParent: clearParent,
          inline: inline,
          construct: construct,
          renderOnConstruction: renderOnConstruction,
          preserveRender: preserveRender,
          id: id,
          generator: generator,
        );

  /// Creates a component attached to an existing [parentComponent].
  ///
  /// This constructor establishes a hierarchical relationship: the new instance
  /// becomes part of the parent component render tree and shares its DOM mapping
  /// context ([domTreeMap]). It should be used for composition inside another
  /// component rather than for standalone roots.
  ///
  /// The optional [parent] is the DOM target used during creation. If null,
  /// the parent component defines the insertion point when rendering.
  ///
  /// Rendering behavior:
  /// * [construct] builds the element immediately.
  /// * [renderOnConstruction] renders right after construction.
  /// * [preserveRender] preserves previously rendered elements in future renders.
  /// * [inline] creates the [content] element as inline.
  ///
  /// Styling:
  /// * [componentClass] / [componentStyle] default values applied to the
  ///   [content] element.
  /// * [classes] / [classes2] are merged CSS classes.
  /// * [style] / [style2] are merged style declarations.
  ///
  /// Structure control:
  /// * [clearParent] optionally clears the container before insertion.
  /// * [generator] the [UIComponentGenerator] used to generate [DOMNode] elements.
  /// * [id] the ID of the component instance (not applied to the [content] element).
  UIComponent.subComponent(
    Object? parent, {
    required UIComponent parentComponent,
    dynamic componentClass,
    dynamic componentStyle,
    dynamic classes,
    dynamic classes2,
    dynamic style,
    dynamic style2,
    UIComponentClearParent? clearParent,
    bool inline = true,
    bool construct = true,
    bool renderOnConstruction = false,
    bool preserveRender = false,
    dynamic id,
    UIComponentGenerator? generator,
  }) : this._(
          parent,
          subComponent: true,
          parentComponent: parentComponent,
          componentClass: componentClass,
          componentStyle: componentStyle,
          classes: classes,
          classes2: classes2,
          style: style,
          style2: style2,
          clearParent: clearParent,
          inline: inline,
          construct: construct,
          renderOnConstruction: renderOnConstruction,
          preserveRender: preserveRender,
          id: id,
          generator: generator,
        );

  void _resolveParent(Object? parent) {
    _resolveParentUIComponent(parent);

    if (_parent == null) {
      if (parent.isElement) {
        _parent = parent as Element;
      } else if (parent is UIComponent) {
        _parent = parent.content;
      }
    }
  }

  void _construct(
    bool preserveRender,
    bool inline,
    classes,
    classes2,
    componentClass,
    style,
    style2,
    componentStyle,
    bool renderOnConstruction,
  ) {
    _constructing = true;
    try {
      this.preserveRender = preserveRender;

      onPreConstruct();

      if (_content == null) {
        _setContent(createContentElement(inline));
      }

      assert(_content != null);

      if (_parentUIComponent == null) {
        if (_parent != null) {
          var uiParent = _getUIComponentByContent(_parent);
          if (uiParent != null) {
            _setParentUIComponent(uiParent);
          } else {
            var renderingUIComponent =
                UIComponent.parentRenderingUIComponent(this);
            if (renderingUIComponent != null) {
              _setParentUIComponent(renderingUIComponent);
            }
          }
        } else if (this is! UIRootComponent) {
          var renderingUIComponent =
              UIComponent.parentRenderingUIComponent(this);
          if (renderingUIComponent != null) {
            _setParentUIComponent(renderingUIComponent);
          }
        }
      }

      registerInUIRoot();

      configureID();

      configureClasses(classes, classes2, componentClass);
      configureStyle(style, style2, componentStyle);

      if (clearParent == UIComponentClearParent.onConstruct) {
        _parent?.clear();
      }

      _parent?.append(_content!);

      configure();

      if (renderOnConstruction) {
        callRender();
      }
    } finally {
      _constructing = false;
    }
  }

  UIComponentInternals get componentInternals => UIComponentInternals(
        this,
        _getContent,
        _setContent,
        _construct,
        _parseAttributes,
        _ensureAllRendered,
        _refreshInternal,
      );

  HTMLElement? _getContent() => _content;

  static final Expando<WeakReference<UIComponent>> _contentsUIComponents =
      Expando();

  static UIComponent? getContentUIComponent(UIElement content) =>
      _contentsUIComponents[content]?.target;

  void _setContent(HTMLElement content) {
    var prev = _content;
    if (prev != null && prev != content) {
      _contentsUIComponents[prev] = null;
    }

    _content = content;
    _contentsUIComponents[content] = WeakReference(this);
  }

  void addTo(UIElement parent, {UIComponent? parentUIComponent}) {
    _setParentImpl(parent, parentUIComponent, addToParent: true);
  }

  void insertTo(int index, UIElement parent, {UIComponent? parentUIComponent}) {
    _setParentImpl(parent, parentUIComponent, addToParent: true);
    parent.insertChild(index, content!);
  }

  /// Called by constructor to register this component in the [UIRoot] tree.
  void registerInUIRoot() {
    var uiRootComponent = this.uiRootComponent;

    if (uiRootComponent != null) {
      uiRootComponent.registerUIComponentInTree(this);
    } else {
      var uiRoot = UIRoot.getInstance();
      uiRoot?.registerUIComponentInTree(this);
    }
  }

  /// Called in the beginning of constructor.
  void onPreConstruct() {}

  UIComponent? clone() => null;

  /// Sets the [parent] [UIElement].
  UIElement? setParent(UIElement parent, {UIComponent? parentUIComponent}) {
    return _setParentImpl(parent, parentUIComponent, addToParent: true);
  }

  UIElement? _setParentImpl(UIElement? parent, UIComponent? parentUIComponent,
      {required bool addToParent}) {
    if (parent == null) throw StateError('Null parent');

    final content = _content;
    if (content != null) {
      if (_parent == parent) {
        if (content.parentElement != _parent) {
          _parent!.appendChild(content);
        }
        _resolveParentUIComponent(parentUIComponent ?? parent);
        return _parent;
      } else if (content.parentElement == parent) {
        _resolveParentUIComponent(parentUIComponent ?? parent);
        return _parent;
      } else {
        content.remove();
      }
    }

    _parentUIComponent = parentUIComponent;
    _parent = parent;

    if (content != null && addToParent) {
      _parent!.append(content);
      clear();
    }

    _resolveParentUIComponent(parentUIComponent ?? parent);
    return _parent;
  }

  /// Returns a [List] of sub [UIComponent].
  List<UIComponent> get subUIComponents {
    var uiRootComponent = this.uiRootComponent;
    return uiRootComponent?.getSubUIComponentsByElement(content) ?? [];
  }

  /// Returns a [List] of sub [UIComponent] deeply in the tree.
  Iterable<UIComponent> get subUIComponentsDeeply sync* {
    var subUIComponents = this.subUIComponents;
    if (subUIComponents.isEmpty) {
      return;
    }

    yield* subUIComponents;

    for (var e in subUIComponents) {
      yield* e.subUIComponentsDeeply;
    }
  }

  void _resolveParentFromParentUIComponent() {
    if (_parent != null) return;

    var content = this.content;
    if (content == null) return;

    final parentUIComponent = _parentUIComponent;
    if (parentUIComponent == null) return;

    var parentUIComponentContent = parentUIComponent.content;
    if (parentUIComponentContent == null) return;

    var contentParent = content.parentElement;

    if (contentParent == null) {
      // print("** not attached: $this");
      return;
    }

    if (contentParent == parentUIComponentContent) {
      _parent = parentUIComponentContent;
    } else if (parentUIComponentContent.contains(content)) {
      _parent = parentUIComponentContent;
    }
  }

  void _setParentUIComponent(UIComponent? uiParent) {
    if (uiParent != null) {
      _parentUIComponent = uiParent;

      _resolveParentFromParentUIComponent();

      _uiRoot = uiParent._uiRoot;
      _uiRootComponent = uiParent._uiRootComponent;
    } else {
      _parentUIComponent = null;
      _uiRoot = null;
      _uiRootComponent = null;
    }
  }

  /// The parent [UIComponent].
  UIComponent? get parentUIComponent =>
      _parentUIComponent ??= _resolveParentUIComponent(_parent);

  UIComponent? _resolveParentUIComponent(Object? parent) {
    if (parent is UIComponent) {
      _setParentUIComponent(parent);
      return parent;
    }

    if (!parent.isElement) return null;

    var foundUIParent = getContentUIComponent(parent as Element) ??
        _getUIComponentByContent(parent) ??
        _getUIComponentByChild(parent);

    if (foundUIParent == null) return null;

    _setParentUIComponent(foundUIParent);
    return foundUIParent;
  }

  static void resolveParentUIComponent(
      {UINode? parent,
      UINode? element,
      UIComponent? parentUIComponent,
      UIComponent? elementUIComponent,
      bool recursive = false}) {
    if ((parent == null && parentUIComponent == null) ||
        (element == null && elementUIComponent == null)) {
      return;
    }

    if (elementUIComponent == null) {
      var element2 = element?.asElementChecked;
      if (element2 != null) {
        elementUIComponent = _resolveNodeUIComponent(element2);
      }

      if (elementUIComponent == null) {
        if (recursive && element2 != null && element2.hasUIChildren) {
          if (parentUIComponent == null && parent.isElement) {
            parentUIComponent = _resolveNodeUIComponent(parent as Element,
                getUIComponentByChild: true);
          }

          if (parentUIComponent != null) {
            for (var child in element2.children.toIterable()) {
              resolveParentUIComponent(
                  parent: parent,
                  parentUIComponent: parentUIComponent,
                  element: child);
            }
          }
        }

        return;
      }
    }

    if (elementUIComponent._parentUIComponent != null) {
      elementUIComponent._resolveParentFromParentUIComponent();
      return;
    }

    if (parentUIComponent == null && parent.isElement) {
      parentUIComponent = _resolveNodeUIComponent(parent as Element,
          getUIComponentByChild: true);
    }

    if (parentUIComponent != null) {
      elementUIComponent._setParentUIComponent(parentUIComponent);
    } else {
      elementUIComponent._resolveParentUIComponent(
          parent ?? parentUIComponent ?? elementUIComponent._parent);
    }
  }

  static UIComponent? _resolveNodeUIComponent(UINode node,
      {bool getUIComponentByChild = false}) {
    var element = node.asElementChecked;
    if (element == null) return null;

    var component = UIComponent.hasUIComponentClass(element)
        ? UIComponent.getContentUIComponent(element)
        : null;

    if (component != null) return component;

    var uiRoot = UIRoot.getInstance();

    if (uiRoot != null) {
      component =
          uiRoot.getUIComponentByContent(element, includePurgedEntries: true);

      if (component == null && getUIComponentByChild) {
        component = uiRoot.getUIComponentByChild(element);
      }
    }

    return component;
  }

  UIRoot? _uiRoot;

  /// Returns the [UIRoot] that is parent of this [UIComponent] instance,
  /// or `null` if it's not in an [UIRoot] components tree.
  UIRoot? get uiRoot => _uiRoot ??= _resolveUIRoot();

  UIRoot? _resolveUIRoot() {
    var parent = parentUIComponent;
    if (parent == null) return null;
    return _uiRoot = parent.uiRoot;
  }

  UIRootComponent? _uiRootComponent;

  /// Returns the [UIRootComponent] that is parent of this [UIComponent] instance,
  /// or `null` if it's not in an [UIRoot] components tree.
  UIRootComponent? get uiRootComponent =>
      _uiRootComponent ??= _resolveUIRootComponent();

  UIRootComponent? _resolveUIRootComponent() {
    var parent = parentUIComponent;
    if (parent == null) {
      var self = this;
      if (self is UIRootComponent) {
        return self;
      }
      return null;
    }

    var root = parent.uiRootComponent;
    if (root == null) {
      var self = this;
      if (self is UIRootComponent) {
        return self;
      }
    }

    return root;
  }

  bool _showing = true;

  bool get isShowing => _showing;

  String? _displayOnHidden;

  /// Hide component.
  void hide() {
    _content!.hidden = true.toJS;

    if (_showing) {
      _displayOnHidden = _content!.style.display;
    }
    _content!.style.display = 'none';

    _showing = false;
  }

  /// Show component.
  void show() {
    _content!.hidden = false.toJS;

    if (!_showing) {
      _content!.style.display = _displayOnHidden ?? '';
      _displayOnHidden = null;
    }

    _showing = true;
  }

  bool get isInDOM {
    return isNodeInDOM(_content!);
  }

  /// Calls: [content.click]
  void click() => content?.click();

  void configureID() {
    setID(id);
  }

  void setID(Object? id) {
    if (id != null) {
      var idStr = parseString(id, '')!.trim();
      if (idStr.isNotEmpty) {
        if (id is String) {
          id = idStr;
        }

        this.id = id;
        _content!.id = idStr;
        return;
      }
    }

    this.id = null;
    _content!.removeAttribute('id');
  }

  static final RegExp _classesEntryDelimiter = RegExp(r'[\s,;]+');

  static List<String> parseClasses(Object? classes1, [Object? classes2]) {
    if (classes1 != null && classes2 != null) {
      var c1 = _parseClasses(classes1);
      var c2 = _parseClasses(classes2);

      if (c1.isNotEmpty && c2.isNotEmpty) {
        return {...c1, ...c2}.toList();
      } else if (c1.isNotEmpty) {
        return c1.length > 1 ? c1.toSet().toList() : c1;
      } else if (c2.isNotEmpty) {
        return c2.length > 1 ? c2.toSet().toList() : c2;
      } else {
        return <String>[];
      }
    } else if (classes1 != null) {
      var c1 = _parseClasses(classes1);
      return c1.length > 1 ? c1.toSet().toList() : c1;
    } else if (classes2 != null) {
      var c2 = _parseClasses(classes2);
      return c2.length > 1 ? c2.toSet().toList() : c2;
    } else {
      return <String>[];
    }
  }

  static List<String> _parseClasses(classes) => toFlatListOfStrings(classes,
      delimiter: _classesEntryDelimiter, trim: true, ignoreEmpty: true);

  void configureClasses(Object? classes1,
      [Object? classes2, Object? componentClasses]) {
    var content = this.content!;
    content.classList.add('ui-component');

    if (componentClasses != null) {
      var classesNamesComponent = parseClasses(componentClasses);
      content.classList.addAll(classesNamesComponent);
    }

    appendClasses(classes1, classes2);
  }

  void appendClasses(Object? classes1, [Object? classes2]) {
    List<String> classesNames;
    if (classes1 != null && classes2 != null) {
      classesNames = <String>[
        ...parseClasses(classes1),
        ...parseClasses(classes2)
      ];
    } else if (classes1 != null) {
      classesNames = parseClasses(classes1);
    } else if (classes2 != null) {
      classesNames = parseClasses(classes2);
    } else {
      return;
    }

    var classesNamesRemove = classesNames
        .where((e) => e.startsWith('!'))
        .map((e) => e.substring(1))
        .toList();

    if (classesNamesRemove.isNotEmpty) {
      classesNames.removeWhere((s) => s.startsWith('!'));
    }

    var content = this.content!;
    content.classList.addAll(classesNames);

    if (classesNamesRemove.isNotEmpty) {
      content.classList.removeAll(classesNamesRemove);
    }
  }

  static bool hasUIComponentClass(UIElement element) =>
      element.classList.contains('ui-component');

  static final RegExp _cssEntryDelimiter = RegExp(r'\s*;\s*');

  static List<String> parseStyle(style1) => toFlatListOfStrings(style1,
      delimiter: _cssEntryDelimiter, trim: true, ignoreEmpty: true);

  void configureStyle(Object? style1,
      [Object? style2, Object? componentStyle]) {
    appendStyle(componentStyle, style1, style2);
  }

  void appendStyle(Object? style1, [Object? style2, Object? style3]) {
    List<String> allStyles;

    if (style1 != null) {
      var styles1 = parseStyle(style1);
      if (style2 != null) {
        var styles2 = parseStyle(style2);
        if (style3 != null) {
          var styles3 = parseStyle(style3);
          allStyles = [...styles1, ...styles2, ...styles3];
        } else {
          allStyles = [...styles1, ...styles2];
        }
      } else {
        allStyles = styles1;
      }
    } else if (style2 != null) {
      var styles2 = parseStyle(style2);
      if (style3 != null) {
        var styles3 = parseStyle(style3);
        allStyles = [...styles2, ...styles3];
      } else {
        allStyles = styles2;
      }
    } else if (style3 != null) {
      allStyles = parseStyle(style3);
    } else {
      return;
    }

    if (allStyles.isNotEmpty) {
      var allStylesLine = allStyles.join('; ');

      final content = this.content!;

      var cssText = content.style.cssText;
      if (cssText == '') {
        cssText = allStylesLine;
      } else {
        cssText += allStylesLine;
      }

      content.style.cssText = cssText;
    }
  }

  static final RegExp _regexpIntlMessage = RegExp(r'\{\{intl?:(\w+)\}\}');

  /// Resolves [text] `{{intl:key}}` messages.
  String resolveTextIntl(String text) {
    if (text.contains('{{')) {
      var uiRoot = this.uiRoot ?? UIRoot.getInstance();

      var intlMessageResolver = uiRoot?.intlMessageResolver;
      intlMessageResolver ??=
          (String key, [Map<String, dynamic>? parameters]) => key;

      return text.replaceAllMapped(_regexpIntlMessage, (m) {
        var key = m[1]!;
        return intlMessageResolver!(key) ?? key;
      });
    } else {
      return text;
    }
  }

  /// Called by constructor, to configure this component.
  void configure() {}

  StreamSubscription<String>? _refreshOnNavigateListener;

  bool get refreshOnNavigate => _refreshOnNavigateListener != null;

  set refreshOnNavigate(bool refresh) {
    if (refreshOnNavigate != refresh) {
      if (refresh) {
        _refreshOnNavigateListener?.cancel();
        _refreshOnNavigateListener =
            UINavigator.onNavigate.listen((_) => this.refresh());
      } else {
        _refreshOnNavigateListener?.cancel();
        _refreshOnNavigateListener = null;
      }
    }
  }

  HTMLElement createContentElement(bool inline) {
    return createDiv(inline: inline);
  }

  UIElement? get parent => _parent;

  HTMLElement? get content => _content;

  List<UIElement> getContentChildren(
      {FilterElement? filter, bool deep = true}) {
    return _getContentChildrenImpl(
        _content!.children.asListViewFixed, <UIElement>[], deep, filter);
  }

  List<UIElement> _getContentChildrenImpl(List<UIElement> list,
      List<UIElement> dst, bool deep, FilterElement? filter) {
    if (deep) {
      _getContentChildrenImplDeep(list, dst, filter);
    } else {
      _getContentChildrenImplShallow(list, dst, filter);
    }
    return dst;
  }

  void _getContentChildrenImplShallow(
      List<UIElement> list, List<UIElement> dst, FilterElement? filter) {
    for (var elem in list) {
      if (filter == null || filter(elem)) {
        dst.add(elem);
      }
    }
  }

  void _getContentChildrenImplDeep(
      List<UIElement> list, List<UIElement> dst, FilterElement? filter) {
    if (list.isEmpty) return;

    final queue = Queue<UIElement>.from(list);

    while (queue.isNotEmpty) {
      final elem = queue.removeFirst();
      if (filter == null || filter(elem)) {
        dst.add(elem);
      }

      var children = elem.children;
      if (children.isNotEmpty) {
        queue.addAll(children.toIterable());
      }
    }
  }

  UIElement? findInContentChildDeep(FilterElement filter) =>
      _findInContentChildDeepImpl(
          _content?.children.asListViewFixed ?? <UIElement>[], filter);

  UIElement? _findInContentChildDeepImpl(
      List<UIElement> list, FilterElement filter) {
    if (list.isEmpty) return null;

    final queue = ListQueue<UIElement>.from(list);

    while (queue.isNotEmpty) {
      final elem = queue.removeFirst();
      if (filter(elem)) return elem;

      var children = elem.children;
      if (children.isNotEmpty) {
        queue.addAll(children.toIterable());
      }
    }

    return null;
  }

  List<UIElement> findChildDeep(FilterElement filter) {
    var list = <UIElement>[];
    _findChildDeepImpl(_content!.children.asListViewFixed, filter, list);
    return list;
  }

  void _findChildDeepImpl(
      List<UIElement> list, FilterElement filter, List<UIElement> dst) {
    if (list.isEmpty) return;

    final queue = Queue<UIElement>.from(list);

    while (queue.isNotEmpty) {
      final elem = queue.removeFirst();

      if (filter(elem)) {
        dst.add(elem);
      }

      var children = elem.children;
      if (children.isNotEmpty) {
        queue.addAll(children.toIterable());
      }
    }
  }

  MapEntry<String, Object>? findChildrenDeep(String fieldName,
          {bool resolveUIComponents = true}) =>
      _findChildrenDeepImpl(
          _content!.children.asListViewFixed, fieldName, resolveUIComponents);

  MapEntry<String, Object>? _findChildrenDeepImpl(
      List<UIElement> list, String fieldName, bool resolveUIComponents) {
    if (list.isEmpty) return null;

    var queue = Queue<UIElement>.from(list);

    while (queue.isNotEmpty) {
      final elem = queue.removeFirst();

      final ret =
          _resolveElementField(elem, resolveUIComponents: resolveUIComponents);
      if (ret != null && ret.key == fieldName) return ret;

      final children = elem.children;
      if (children.isNotEmpty) {
        queue.addAll(children.toIterable());
      }
    }

    return null;
  }

  List<Object> getFieldsComponents() =>
      getFieldsComponentsMap().values.toList();

  Map<String, Object> getFieldsComponentsMap(
      {List<String>? fields, List<String>? ignoreFields}) {
    var map = Map<String, Object>.fromEntries(
        _listFieldsEntriesInContentDeepImpl(_content!.children.toList()));

    if (fields != null) {
      map.removeWhere((key, value) => !fields.contains(key));
    }

    if (ignoreFields != null) {
      map.removeWhere((key, value) => ignoreFields.contains(key));
    }

    return map;
  }

  List<MapEntry<String, Object>> _listFieldsEntriesInContentDeepImpl(
      List<UIElement> list) {
    final result = <MapEntry<String, Object>>[];
    if (list.isEmpty) return result;

    final queue = ListQueue<UIElement>.from(list);

    while (queue.isNotEmpty) {
      final elem = queue.removeFirst();
      final entry = _resolveElementField(elem);
      if (entry != null) {
        result.add(entry);
      } else {
        final children = elem.children;
        if (children.isNotEmpty) {
          queue.addAll(children.toIterable());
        }
      }
    }

    return result;
  }

  String? _renderedElementsLocale;

  bool? _renderedElementsAsync;

  bool get renderedElementsAsync => _renderedElementsAsync ?? false;

  List<Object>? _renderedElements;

  List<Object>? get renderedElements =>
      _renderedElements != null ? List.unmodifiable(_renderedElements!) : null;

  dynamic getRenderedElement(FilterRendered filter, [bool? deep]) {
    if (_renderedElements == null) return null;

    for (var elem in _renderedElements!) {
      if (filter(elem)) return elem;
    }

    if (deep ?? false) {
      for (var elem in _renderedElements!) {
        if (elem is UIComponent) {
          var found = elem.getRenderedElement(filter, true);
          if (found != null) {
            return found;
          }
        }
      }

      var subUIComponents = this.subUIComponents;

      for (var elem in subUIComponents) {
        if (filter(elem)) return elem;

        var found = elem.getRenderedElement(filter, true);
        if (found != null) {
          return found;
        }
      }
    }

    return null;
  }

  List? getAllRenderedElements(FilterRendered filter, [bool deep = false]) {
    if (_renderedElements == null) return null;

    var elements = <dynamic>{};

    for (var elem in _renderedElements!) {
      if (filter(elem)) {
        elements.add(elem);
      }
    }

    if (deep) {
      for (var elem in _renderedElements!) {
        if (elem is UIComponent) {
          var found = elem.getRenderedElement(filter, true);
          if (found != null) {
            elements.add(found);
          }
        }
      }

      var subUIComponents = this.subUIComponents;

      for (var elem in subUIComponents) {
        if (filter(elem)) {
          elements.add(elem);
        }

        var found = elem.getRenderedElement(filter, true);
        if (found != null) {
          elements.add(found);
        }
      }
    }

    return elements.toList();
  }

  dynamic getRenderedElementValueById(dynamic id, [bool deep = false]) {
    var element = getRenderedElementById(id, deep);
    if (element == null) return null;
    var value = getElementValue(element);
    return value;
  }

  dynamic getRenderedElementById(dynamic id, [bool deep = false]) =>
      getRenderedElement(
          (elem) =>
              (elem is UIComponent && elem.id == id) ||
              (elem.isElement && (elem as Element).id == id),
          deep);

  T? getRenderedUIComponentById<T extends UIComponent>(dynamic id,
      [bool? deep]) {
    if (id == null) return null;
    var components = getRenderedUIComponents(deep);
    return components.whereType<T>().firstWhereOrNull((e) => e.id == id);
  }

  List<UIComponent> getRenderedUIComponentsByIds<T extends UIComponent>(
      List ids,
      [bool? deep]) {
    if (ids.isEmpty) return <UIComponent>[];
    return getRenderedUIComponents(deep)
        .whereType<T>()
        .where((e) => e.id != null && ids.contains(e.id))
        .toList();
  }

  List<T> getRenderedUIComponentByType<T>([bool? deep]) =>
      getRenderedUIComponents(deep).whereType<T>().toList();

  Iterable<UIComponent> getRenderedUIComponents([bool? deep]) =>
      (deep ?? false) ? subUIComponentsDeeply : subUIComponents;

  bool _rendered = false;

  bool get isRendered => _rendered;

  /// Clears the component, removing the last rendered content.
  /// - If [force] is `true` performs a clear operation even if [isRendered] returns `false`.
  /// - If [removeFromParent] is `true` it will also remove the [content] element from the [parent].
  void clear({bool force = false, bool removeFromParent = false}) {
    if (!force && !isRendered) return;

    if (!force && preserveRender) {
      // When any UIAsyncContent is loading, it relies on the previously
      // rendered elements to attach the newly loaded content, replacing
      // the old nodes. Clearing the component elements here would break
      // that attachment process.
      if (isLoadingUIAsyncContent) {
        return;
      }
    }

    if (_renderedElements != null) {
      for (var e in _renderedElements!) {
        if (e is UIComponent) {
          e.delete();
        } else if (e.isElement) {
          (e as Element).remove();
        }
      }

      _renderedElements = null;
    }

    _renderedAsyncContents?.clear();
    _renderedAsyncContents = null;

    var content = _content;

    if (content != null) {
      var elements = content.children.toList();
      for (var e in elements) {
        e.remove();
      }

      content.clear();

      if (removeFromParent) {
        content.remove();
      }
    }

    _rendered = false;
  }

  Future<void>? _requestRefresh;

  /// Requests a [refresh] using [Future.microtask] or [Future.delayed].
  ///
  /// - If a [refresh] request is already pending, subsequent requests are ignored
  ///   until the current [refresh] is completed.
  /// - This method prevents redundant [refresh] operations triggered by rapid
  ///   state changes.
  /// - If a [delay] is provided, the request uses [Future.delayed]; otherwise,
  ///   it defaults to [Future.microtask].
  void requestRefresh({Duration? delay, bool clearPreservedRender = false}) {
    var future = _requestRefresh;
    if (future != null) return;

    if (delay != null && delay.inMilliseconds >= 1) {
      _requestRefresh = future = Future.delayed(delay, () {
        if (identical(future, _requestRefresh)) {
          _requestRefresh = null;
        }
        refresh(clearPreservedRender: clearPreservedRender);
      });
    } else {
      _requestRefresh = future = Future.microtask(() {
        if (identical(future, _requestRefresh)) {
          _requestRefresh = null;
        }
        refresh(clearPreservedRender: clearPreservedRender);
      });
    }
  }

  bool __refreshFromExternalCall = false;

  bool get isRefreshFromExternalCall => __refreshFromExternalCall;

  void _refreshInternal() {
    _refreshImpl(forceRender: false);
  }

  void refreshInternal() {
    _refreshImpl(forceRender: false);
  }

  /// Refreshes the component, calling [render].
  /// - If ![isRendered] it won't refresh the component.
  ///   Use [forceRender] if you want to ensure that it will be rendered even if
  ///   it wasn't rendered yet. A component is automatically rendered when
  ///   constructed. If a component has not yet been rendered, it may not have
  ///   been properly constructed or initialized yet.
  void refresh({bool forceRender = false, bool clearPreservedRender = false}) {
    try {
      __refreshFromExternalCall = true;

      _refreshImpl(
          forceRender: forceRender, clearPreservedRender: clearPreservedRender);
    } finally {
      __refreshFromExternalCall = false;
    }
  }

  void _refreshImpl(
      {required bool forceRender, bool clearPreservedRender = false}) {
    if (!forceRender && !isRendered) return;
    callRender(clear: true, clearPreservedRender: clearPreservedRender);
  }

  void refreshIfLocaleChanged() {
    try {
      __refreshFromExternalCall = true;

      _refreshIfLocaleChangedImpl();
    } finally {
      __refreshFromExternalCall = false;
    }
  }

  void _refreshIfLocaleChangedImpl() {
    if (!isRendered) return;
    if (localeChangedFromLastRender) {
      UIConsole.log(
          'Locale changed: $_renderLocale -> ${UIRoot.getCurrentLocale()} ; Refreshing...');
      clear();
      callRender();
    }
  }

  void delete() {
    clear();
    content!.remove();
  }

  void ensureRendered([bool force = false]) {
    if (!isRendered) {
      callRender();
    } else if (localeChangedFromLastRender || isDisposed) {
      callRender(clear: true);
    } else if (force) {
      callRender(clear: true);
    }
  }

  bool isAccessible() {
    return true;
  }

  String? deniedAccessRoute() {
    return null;
  }

  void callRenderAsync() {
    Future.microtask(callRender);
  }

  bool get localeChangedFromLastRender {
    var currentLocale = UIRoot.getCurrentLocale();
    return _renderLocale != currentLocale;
  }

  bool deviceSizeChangedFromLastRender(
      {double tolerance = 0.10,
      bool onlyWidth = false,
      bool onlyHeight = false}) {
    if (_renderDeviceWidth == null || _renderDeviceHeight == null) {
      return false;
    }

    var w = deviceWidth!;
    var h = deviceHeight!;

    var rw = Math.max(_renderDeviceWidth! / w, w / _renderDeviceWidth!) - 1;
    var rh = Math.max(_renderDeviceHeight! / h, h / _renderDeviceHeight!) - 1;

    //print('deviceSizeChangedFromLastRender>> $_renderDeviceWidth / $w ; $_renderDeviceHeight / $h > $rw ; $rh > $tolerance');

    if (onlyWidth) {
      return rw > tolerance;
    } else if (onlyHeight) {
      return rh > tolerance;
    } else {
      return rw > tolerance || rh > tolerance;
    }
  }

  static bool get isAnyComponentRendering =>
      UIRoot.getInstance()?.isAnyComponentRendering ?? false;

  static UIComponent? _getUIComponentByContent(UIElement? content) {
    if (content == null) return null;
    return _getUIComponent((o) => o.getUIComponentByContent(content));
  }

  static UIComponent? _getUIComponentByChild(UIElement? content) {
    if (content == null) return null;
    return _getUIComponent((o) => o.getUIComponentByChild(content));
  }

  static UIComponent? _getUIComponent(
      UIComponent? Function(UIRootComponent uiRootComponent) caller) {
    var uiRoot = UIRoot.getInstance();
    if (uiRoot != null) {
      var uiComponent = caller(uiRoot);
      if (uiComponent != null) {
        return uiComponent;
      }
    }

    var uiRootComponents = UIRootComponent.getInstances();
    for (var uiRootComponent in uiRootComponents.reversed) {
      if (uiRootComponent == uiRoot) continue;

      var uiComponent = caller(uiRootComponent);
      if (uiComponent != null) {
        return uiComponent;
      }
    }

    return null;
  }

  UIComponent? findUIComponentByID(String id) {
    if (id.startsWith('#')) id = id.substring(1);
    if (isEmptyString(id)) return null;
    return _findUIComponentByIDImpl(id);
  }

  UIComponent? _findUIComponentByIDImpl(String id) {
    if (_content == null) return null;
    if (_content!.id == id) return this;
    if (_renderedElements == null || _renderedElements!.isEmpty) return null;

    for (var elem in _renderedElements!) {
      if (elem is UIComponent) {
        if (elem.id == id) return elem;
        var uiComp = elem._findUIComponentByIDImpl(id);
        if (uiComp != null) return uiComp;
      }
    }

    var subUIComponents = this.subUIComponents;

    for (var elem in subUIComponents) {
      if (elem.id == id) return elem;
      var uiComp = elem._findUIComponentByIDImpl(id);
      if (uiComp != null) return uiComp;
    }

    return null;
  }

  UIComponent? findUIComponentByContent(UIElement? content) {
    if (content == null) return null;
    if (content == _content) return this;

    if (_renderedElements == null || _renderedElements!.isEmpty) return null;

    for (var elem in _renderedElements!) {
      if (elem is UIComponent) {
        var uiComp = elem.findUIComponentByContent(content);
        if (uiComp != null) return uiComp;
      }
    }

    var subUIComponents = this.subUIComponents;

    for (var elem in subUIComponents) {
      var uiComp = elem.findUIComponentByChild(content);
      if (uiComp != null) return uiComp;
    }

    for (var elem in _content!.children.toIterable()) {
      if (content == elem) {
        return this;
      }
    }

    return null;
  }

  UIComponent? findUIComponentByChild(UIElement? child) {
    if (child == null) return null;
    if (child == _content) return this;

    for (var elem in _content!.children.toIterable()) {
      if (child == elem) {
        return this;
      }
    }

    if (_renderedElements != null && _renderedElements!.isNotEmpty) {
      for (var elem in _renderedElements!) {
        if (elem is UIComponent) {
          var uiComp = elem.findUIComponentByChild(child);
          if (uiComp != null) return uiComp;
        }
      }
    }

    var subUIComponents = this.subUIComponents;

    for (var elem in subUIComponents) {
      var uiComp = elem.findUIComponentByChild(child);
      if (uiComp != null) return uiComp;
    }

    var deepChild = findInContentChildDeep((elem) => child == elem);
    if (deepChild != null) return this;

    return null;
  }

  bool _rendering = false;

  bool get isRendering => _rendering;

  bool _callingRender = false;

  void callRender({bool clear = false, bool clearPreservedRender = false}) {
    if (_callingRender) return;

    _callingRender = true;
    try {
      _callRenderImpl(clear, clearPreservedRender);
    } catch (e, s) {
      UIConsole.error('Error calling _callRenderImpl()', e, s);
    } finally {
      _callingRender = false;
    }
  }

  void preRenderClear() {
    clear();
  }

  int _renderCount = 0;

  int get renderCount => _renderCount;

  static final Queue<Zone> _renderingZonePool = Queue();

  Zone _catchRenderingZone() {
    if (_renderingZonePool.isNotEmpty) {
      return _renderingZonePool.removeLast();
    }
    return Zone.current.fork();
  }

  void _releaseRenderingZone(Zone zone) {
    _releaseRenderingZoneUIComponent();
    _renderingZonePool.addLast(zone);
  }

  Zone? _renderingZone;

  Zone _resolveRenderingZone() {
    var renderingZone = _renderingZone;
    if (renderingZone != null) return renderingZone;

    return _catchRenderingZone();
  }

  static final DualLazyWeakMap<Zone, UIComponent> _asyncRenderingZoneComponent =
      DualLazyWeakMap<Zone, UIComponent>(
    LazyWeakReferenceManagerByType.global.get<Zone>(),
    LazyWeakReferenceManagerByType.global.get<UIComponent>(),
  );

  void _setRenderingZoneUIComponent(Zone renderingZone) {
    _renderingZone = renderingZone;
    _asyncRenderingZoneComponent[renderingZone] = this;
  }

  void _releaseRenderingZoneUIComponent() {
    var renderingZone = _renderingZone;
    if (renderingZone != null) {
      _renderingZone = null;
      _asyncRenderingZoneComponent.remove(renderingZone);
    }
  }

  static final List<UIComponent> _renderingUIComponent = [];

  /// Returns the current synchronous rendering [UIComponent] in the rendering stack.
  static UIComponent? get renderingUIComponent =>
      _renderingUIComponent.lastOrNull;

  /// Returns the parent rendering [UIComponent] of [uiComponent], if any.
  ///
  /// If [uiComponent] is currently being rendered, this method may return:
  /// - The component itself when it is the active rendering context.
  /// - The nearest rendering ancestor, when available.
  ///
  /// The lookup works in two stages:
  /// - Checks the synchronous rendering stack.
  /// - Falls back to asynchronous rendering contexts using rendering [Zone]s.
  ///
  /// Returns `null` if no parent rendering component can be resolved.
  static UIComponent? parentRenderingUIComponent(UIComponent uiComponent) {
    final renderingUIComponent = UIComponent._renderingUIComponent;

    if (renderingUIComponent.isNotEmpty) {
      var renderingComponent = renderingUIComponent.last;
      if (!identical(renderingComponent, uiComponent)) {
        return renderingComponent;
      }

      if (renderingUIComponent.length > 1) {
        for (var i = renderingUIComponent.length - 2; i >= 0; --i) {
          renderingComponent = renderingUIComponent[i];
          if (!identical(renderingComponent, uiComponent)) {
            return renderingComponent;
          }
        }
      }

      return null;
    }

    Zone? currentZone = Zone.current;

    while (currentZone != null) {
      var asyncComponent = _asyncRenderingZoneComponent[currentZone];
      if (asyncComponent == null) {
        return null;
      } else if (!identical(asyncComponent, uiComponent)) {
        return asyncComponent;
      }

      currentZone = currentZone.parent;
    }

    return null;
  }

  void _callRenderImpl(bool clear, bool clearPreservedRender) {
    _renderCount++;
    _requestRefresh = null;

    var content = this.content;
    // Prevent render of not initialized components:
    if (content == null) {
      return;
    }

    // Recycle disposed component:
    if (_disposed) {
      _recycle();
    }

    final parent = _parent;
    if (parent != null) {
      if (clearParent == UIComponentClearParent.onRender ||
          (clearParent == UIComponentClearParent.onInitialRender &&
              _renderCount == 1)) {
        // content not added to parent:
        if (content.parentNode != parent) {
          parent.clear();
          parent.appendChild(content);
        }
        // content already added, remove other nodes:
        else {
          var nodes = parent.childNodes.toList();

          var containsContent = false;
          for (var node in nodes) {
            if (node == content) {
              containsContent = true;
            } else {
              node.remove();
            }
          }

          // Improbable to happen, unless it's an odd browser:
          if (!containsContent) {
            // If not already in the `parent`'s hierarchy:
            if (!parent.contains(content)) {
              parent.append(content);
            }
          }
        }
      } else {
        var appended = content.parentNode == parent;
        if (!appended) {
          // If not already in the `parent`'s hierarchy:
          if (!parent.contains(content)) {
            parent.append(content);
          }
        }
      }
    }

    if (clear) {
      preRenderClear();
    }

    _rendering = true;
    _renderingUIComponent.add(this);

    var renderingZone = _resolveRenderingZone();

    Object? rendered;
    try {
      rendered = renderingZone.run(() => _doRender(clearPreservedRender));
    } finally {
      _rendering = false;

      var lastRendering = _renderingUIComponent.lastOrNull;
      if (identical(lastRendering, this)) {
        _renderingUIComponent.removeLast();
      } else {
        UIConsole.error(
            'Last `_renderingComponent` != `this`: $lastRendering != $this');
      }

      // Asynchronous render:
      // Mark `renderingZone` with `this` [UIComponent].
      if (rendered is Future) {
        _setRenderingZoneUIComponent(renderingZone);
      }
      // Normal render:
      // Release `renderingZone` in the pool to be reused.
      else {
        _releaseRenderingZone(renderingZone);
      }

      try {
        _notifyRendered();
      } catch (e, s) {
        UIConsole.error('$this _notifyRendered error', e, s);
      }

      try {
        _notifyRenderToParent();
      } catch (e, s) {
        UIConsole.error('$this _notifyRefreshToParent error', e, s);
      }
    }
  }

  int _preserveRenderCount = 0;

  int get preserveRenderCount => _preserveRenderCount;

  String? _renderLocale;
  int? _renderDeviceWidth;
  int? _renderDeviceHeight;

  Object? _doRender(bool clearPreservedRender) {
    var currentLocale = UIRoot.getCurrentLocale();

    _renderLocale = currentLocale;
    _renderDeviceWidth = deviceWidth;
    _renderDeviceHeight = deviceHeight;

    try {
      if (!isAccessible()) {
        UIConsole.log('Not accessible: $this');

        _rendered = true;

        var redirectToRoute = deniedAccessRoute();

        if (redirectToRoute != null) {
          if (!isInDOM) {
            UIConsole.log(
                '[NOT IN DOM] Denied access to route: $redirectToRoute');
          } else {
            UIConsole.log('Denied access to route: $redirectToRoute');
            UINavigator.navigateToAsync(redirectToRoute);
          }
        }

        return null;
      }
    } catch (e, s) {
      UIConsole.error('$this isAccessible error', e, s);
      return null;
    }

    Object? rendered;
    try {
      _callPreRender();

      _rendered = true;

      if (preserveRender &&
          !clearPreservedRender &&
          !_renderedWithError &&
          _renderedElements != null &&
          _renderedElements!.isNotEmpty &&
          _renderedElementsLocale == _renderLocale) {
        _preserveRenderCount++;
        rendered = List.from(_renderedElements!);
      } else {
        _renderedWithError = false;
        _preserveRenderCount = 0;
        _renderedElements = null;

        _renderedAsyncContents = null;

        rendered = render();
      }

      var renderedElements = toContentElements(rendered);

      _renderedElements = renderedElements;
      _renderedElementsLocale = _renderLocale;
      _renderedElementsAsync = rendered is Future;

      _ensureAllRendered(renderedElements);
    } catch (e, s) {
      UIConsole.error('$this render error', e, s);
    }

    _finalizeRender();

    try {
      _parseAttributesPosRender(content!.children.asListViewFixed);
    } catch (e, s) {
      UIConsole.error('$this _parseAttributesPosRender(...) error', e, s);
    }

    _callPosRender();

    _markRenderTime(this, _uiRoot);

    return rendered;
  }

  void _finalizeRender() {
    setTreeElementsBackgroundBlur(content!, 'bg-blur');
  }

  void _ensureAllRendered(List<Object?> elements) {
    if (elements.isEmpty) return;

    for (var e in elements) {
      if (e is UIComponent) {
        e.ensureRendered();
      } else if (e.isElement) {
        var subElements = <Element>[];

        var children = (e as Element).children.toList();
        for (var child in children) {
          var classUiComponent = hasUIComponentClass(child);

          var uiComponent = classUiComponent
              ? _getUIComponentFromUIRootByContent(child)
              : null;

          if (uiComponent != null) {
            uiComponent.ensureRendered();
          } else if (child.children.isNotEmpty) {
            subElements.add(child);
          }
        }

        _ensureAllElementsRendered(subElements);
      }
    }
  }

  void _ensureAllElementsRendered(List<Element> elements) {
    if (elements.isEmpty) return;

    for (var e in elements) {
      var subElements = <Element>[];

      var children = e.children.toList();
      for (var child in children) {
        var classUiComponent = hasUIComponentClass(child);

        var uiComponent =
            classUiComponent ? _getUIComponentFromUIRootByContent(child) : null;

        if (uiComponent != null) {
          uiComponent.ensureRendered();
        } else if (child.children.isNotEmpty) {
          subElements.add(child);
        }
      }

      _ensureAllRendered(subElements);
    }
  }

  UIComponent? _getUIComponentFromUIRootByContent(UIElement? content) {
    if (content == null) return null;

    final uiRoot = _uiRoot;
    if (uiRoot != null) {
      return uiRoot.getUIComponentByContent(content);
    }

    return _getUIComponent((o) => o.getUIComponentByContent(content));
  }

  EventStream<UIComponent>? _onRender;

  EventStream<UIComponent> get onRender => _onRender ??= EventStream();

  void _notifyRendered() {
    var waitingRender = _waitingRender;
    if (waitingRender != null && !waitingRender.isCompleted) {
      waitingRender.complete(true);
      _waitingRender = null;
    }

    final onRender = _onRender;
    if (onRender != null && onRender.isUsed) {
      Future.delayed(Duration(milliseconds: 1), () => onRender.add(this));
    }
  }

  Completer<bool>? _waitingRender;

  Future<bool> waiteRender({Duration timeout = const Duration(seconds: 3)}) {
    var waitingRender = _waitingRender ??= Completer<bool>();

    if (timeout.inMilliseconds >= 1) {
      return waitingRender.future.timeout(timeout, onTimeout: () => false);
    } else {
      return waitingRender.future;
    }
  }

  Future<bool> callRenderAndWait(
      {Duration timeout = const Duration(seconds: 3)}) {
    var wait = waiteRender(timeout: timeout);
    callRender();
    return wait;
  }

  void _notifyRenderToParent() {
    var parentUIComponent = this.parentUIComponent;
    if (parentUIComponent == null) return;

    parentUIComponent._callOnChildRendered(this);
  }

  void _callOnChildRendered(UIComponent child) {
    try {
      onChildRendered(this);
    } catch (e, s) {
      logger.error('Error calling onChildRendered() for instance: $this', e, s);
    }
  }

  void onChildRendered(UIComponent child) {}

  EventStream<dynamic>? _onChange;

  EventStream<dynamic> get onChange => _onChange ??= EventStream();

  static int _lastRenderTime = DateTime.now().millisecondsSinceEpoch;

  static bool _renderFinished = true;

  static final Set<UIRoot> _renderedUIRoots = {};
  static final Set<UIComponent> _renderedUIComponents = {};

  static void _markRenderTime(UIComponent uiComponent, UIRoot? uiRoot) {
    _lastRenderTime = DateTime.now().millisecondsSinceEpoch;
    _renderFinished = false;

    _renderedUIComponents.add(uiComponent);

    if (uiRoot != null) {
      _renderedUIRoots.add(uiRoot);
    }

    _scheduleCheckFinishedRendered();
  }

  static Future<void>? _scheduleCheckFinishedRenderedFuture;

  static void _scheduleCheckFinishedRendered() {
    var future = _scheduleCheckFinishedRenderedFuture;
    if (future != null) return;

    future = _scheduleCheckFinishedRenderedFuture =
        Future.delayed(Duration(milliseconds: 300), _checkFinishedRendered);

    future.whenComplete(() {
      if (identical(future, _scheduleCheckFinishedRenderedFuture)) {
        _scheduleCheckFinishedRenderedFuture = null;
      }
    });
  }

  static void _checkFinishedRendered() {
    if (_renderFinished) return;

    var now = DateTime.now().millisecondsSinceEpoch;
    var delay = now - _lastRenderTime;

    if (delay > 100) {
      _notifyFinishRendered();
    } else {
      Future.delayed(
          Duration(milliseconds: 100), _scheduleCheckFinishedRendered);
    }
  }

  static Future<void>? _notifyFinishRenderedFuture;

  static void _notifyFinishRendered() {
    var future = _notifyFinishRenderedFuture;
    if (future != null) return;

    future = _notifyFinishRenderedFuture = _notifyFinishRenderedImpl();

    future.whenComplete(() {
      if (identical(future, _notifyFinishRenderedFuture)) {
        _notifyFinishRenderedFuture = null;
      }
    });
  }

  static Future<void> _notifyFinishRenderedImpl() async {
    if (_renderFinished) return;
    _renderFinished = true;

    if (UILayout.someInstanceNeedsRefresh()) {
      UILayout.refreshAll();
    } else {
      UILayout.checkInstances();
    }

    var mainUIRoot = UIRoot.getInstance();

    var uiComponents = _renderedUIComponents.toList();
    var uiRoots = {
      ..._renderedUIRoots,
      if (mainUIRoot != null) mainUIRoot,
    };

    _renderedUIComponents.clear();
    _renderedUIRoots.clear();

    for (var uiRoot in uiRoots) {
      uiRoot.notifyFinishRender();
    }

    Future.delayed(
        Duration(milliseconds: 300), () => _purgeUI(uiComponents, uiRoots));
  }

  static Future<void> _purgeUI(
      List<UIComponent> uiComponents, Set<UIRoot> uiRoots) async {
    for (var uiComponent in uiComponents) {
      await uiComponent._onPurge();
    }

    for (var uiRoot in uiRoots) {
      await uiRoot.purgeRoot();
    }
  }

  Future<void> _onPurge() async {
    if (_subComponent) return;

    final domTreeMap = _domTreeMap;
    if (domTreeMap == null) return;

    domTreeMap.purge();
    await yeld();
  }

  /// If [true] will preserve last render in next calls to [render].
  bool preserveRender = false;

  /// Clears previous rendered elements. Only relevant if [preserveRender] is true.
  void clearPreservedRender() {
    if (preserveRender) {
      _renderedElements = [];
    }
  }

  /// Called when [render] returns a [Future] value, to render the content
  /// while loading `Future`.
  dynamic renderLoading() => uiRoot?.renderLoading();

  bool _renderedWithError = false;

  /// Returns [true] if current/last render had errors.
  bool get isRenderedWithError => _renderedWithError;

  /// Marks current/last render with error.
  void markRenderedWithError() => _renderedWithError = true;

  /// Called when [render] returns a `Future` value, to render the content
  /// when [Future] has an error.
  dynamic renderError(dynamic error) => null;

  /// Called before [render].
  void preRender() {}

  /// Renders the elements of this component.
  ///
  /// Accepted return types:
  /// - `web` [UINode] and [UIElement].
  /// - [DIVElement], [DOMNode], [AsDOMElement] and [AsDOMNode].
  /// - [Future].
  /// - [UIAsyncContent].
  /// - [String], parsed as `HTML`.
  /// - [Map] (rendered as JSON).
  /// - [List] with previous types (recursively).
  /// - [Function] that returns any previous type. Including [Function]<[Future]>, allowing `async` functions.
  dynamic render();

  /// Called after [render].
  void posRender() {}

  void _callPreRender() {
    try {
      preRender();
    } catch (e, s) {
      UIConsole.error('$this preRender error', e, s);
    }
  }

  void _callPosRender() {
    try {
      posRender();
    } catch (e, s) {
      UIConsole.error('$this posRender error', e, s);
    }

    connectDataSource();
  }

  List<Object> toContentElements(dynamic rendered,
      {bool append = false, bool parseAttributes = true}) {
    try {
      var domContext = UIComponentDOMContext(this, domGenerator.domContext);

      var list = _toContentElementsImpl(rendered, append, domContext);

      if (parseAttributes) {
        _parseAttributes(content!.children.asListViewFixed);
      }

      return list;
    } catch (e, s) {
      logger.error(
          'Error converting rendered to content elements: $rendered', e, s);
      return <Object>[];
    }
  }

  static bool isRenderable(Object? element) {
    if (element == null) return false;
    return element.isElement ||
        element is UIContent ||
        element is UIAsyncContent;
  }

  static dynamic copyRenderable(dynamic element, [dynamic def]) {
    if (element is String) return element;

    if (element is UIComponent) {
      var clone = element.clone();
      return clone ?? (isRenderable(def) ? def : null);
    } else if (isRenderable(element)) {
      return element;
    } else {
      return null;
    }
  }

  List<Object>? toRenderableList(Object? list,
      [DOMContext<UINode>? domContext]) {
    if (list == null) return null;

    List<Object> renderableList;

    if (list is List<Object>) {
      renderableList = list;
    } else if (list is Iterable<Object?>) {
      renderableList = List.from(list.nonNulls);
    } else if (list is Map) {
      renderableList = [];

      for (var entry in list.entries) {
        var key = entry.key;
        var val = entry.value;
        if (isRenderable(key)) {
          renderableList.add(key);
        }
        if (isRenderable(val) || isHTMLElement(val)) {
          renderableList.add(val);
        }
      }
    } else {
      renderableList = [list];
    }

    return renderableList;
  }

  List<Object> _toContentElementsImpl(
      Object? rendered, bool append, DOMContext<UINode>? domContext) {
    var renderableList = toRenderableList(rendered, domContext);

    var content = this.content!;

    if (renderableList == null || renderableList.isEmpty) {
      if (!append) {
        content.clear();
      }

      return <Object>[];
    }

    if (isListOfStrings(renderableList)) {
      var html = renderableList.join('\n');

      var domNodes = $html(html);

      var nodes = domNodes
          .map((e) => e.buildDOM(
              generator: domGenerator,
              treeMap: domTreeMap,
              parent: content,
              context: domContext,
              setTreeMapRoot: false))
          .nonNulls
          .toList();

      if (append) {
        content.appendAll(nodes);
      } else {
        content.clear();
        content.appendAll(nodes);
      }

      var renderedList = List<Object>.from(content.childNodes.toList());
      return renderedList;
    } else {
      if (isListValuesIdentical(renderableList, content.childNodes.toList())) {
        return List<Object>.from(renderableList);
      }

      for (var value in renderableList) {
        _removeFromContent(value);
      }

      var renderedList2 = <Object>[];

      var prevElemIndex = -1;

      for (var value in renderableList) {
        prevElemIndex =
            _buildRenderList(value, renderedList2, prevElemIndex, domContext);
      }

      return renderedList2;
    }
  }

  Object? _normalizeRenderListValue(
      UIElement? content, Object? value, DOMContext<UINode>? domContext) {
    if (value == null) {
      return null;
    } else if (value is DOMNode) {
      return value.buildDOM(
          generator: domGenerator,
          treeMap: domTreeMap,
          parent: content,
          context: domContext,
          setTreeMapRoot: false);
    } else if (value is UIComponent) {
      return value;
    } else if (value is String) {
      var nodes = $html(value);
      return nodes;
    } else if (value is List) {
      return value;
    } else if (value is Iterable) {
      return value.toList();
    } else if (value.isNode) {
      return value;
    } else if (value is Function) {
      return value;
    } else if (value is Future) {
      var asyncContent = UIAsyncContent.future(
        value,
        () {
          return renderLoading() ?? '...';
        },
        errorContent: (error) {
          markRenderedWithError();
          return renderError(error) ?? '[error: $error]';
        },
        properties: {'__Future__': value},
      )..parentUIComponent = this;
      return asyncContent;
    } else if (value is AsDOMElement) {
      var element = value.asDOMElement;
      return element.buildDOM(
          generator: domGenerator,
          treeMap: domTreeMap,
          parent: content,
          context: domContext,
          setTreeMapRoot: false);
    } else if (value is AsDOMNode) {
      var node = value.asDOMNode;
      return node.buildDOM(
          generator: domGenerator,
          treeMap: domTreeMap,
          parent: content,
          context: domContext,
          setTreeMapRoot: false);
    } else if (value is Map ||
        (value is List && listMatchesAll(value, (dynamic e) => e is Map))) {
      return UIJsonRender(null, json: value);
    } else {
      return value;
    }
  }

  int _buildRenderList(Object? value, List<dynamic> renderedList,
      int prevElemIndex, DOMContext<UINode>? domContext) {
    if (value == null) return prevElemIndex;
    final content = this.content;

    value = _normalizeRenderListValue(content, value, domContext);
    if (value == null) return prevElemIndex;

    if (value.isNode) {
      prevElemIndex = _addElementToRenderList(
          value, value as Node, renderedList, prevElemIndex);
    } else if (value is UIComponent) {
      if (value.parent != content) {
        value._setParentImpl(content, this, addToParent: false);
      }
      prevElemIndex = _addElementToRenderList(
          value, value.content!, renderedList, prevElemIndex);
    } else if (value is UIAsyncContent) {
      prevElemIndex = _addUIAsyncContentToRenderList(
          value, renderedList, prevElemIndex, domContext);
    } else if (value is List) {
      for (var elem in value) {
        prevElemIndex =
            _buildRenderList(elem, renderedList, prevElemIndex, domContext);
      }
    } else if (value is Function) {
      try {
        // ignore: avoid_dynamic_calls
        var result = value();
        prevElemIndex =
            _buildRenderList(result, renderedList, prevElemIndex, domContext);
      } catch (e, s) {
        UIConsole.error('Error calling function: $value', e, s);
      }
    } else if (value is InputConfig) {
      var msg =
          "Bones_UI: Can't render element of type `InputConfig` as it exclusive to `UIInputTable`!";

      UIConsole.log(msg);
      UIConsole.log(value);
      throw UnsupportedError(msg);
    } else {
      var msg = "Bones_UI: Can't render element of type: ${value.runtimeType}";

      UIConsole.log(msg);
      UIConsole.log(value);
      throw UnsupportedError(msg);
    }

    return prevElemIndex;
  }

  void _callPosAsyncRender() {
    try {
      posAsyncRender();
    } catch (e, s) {
      UIConsole.error('$this posAsyncRender error', e, s);
    }
  }

  void posAsyncRender() {}

  Map<UIAsyncContent, List>? _renderedAsyncContents;
  Set<UIAsyncContent>? _loadingAsyncContents;

  bool get isLoadingUIAsyncContent =>
      _loadingAsyncContents?.isNotEmpty ?? false;

  void _resolveUIAsyncContentLoaded(
      UIAsyncContent asyncContent, DOMContext<UINode>? domContext) {
    if (!asyncContent.isLoaded) return;

    if (asyncContent.isLoaded && !asyncContent.hasAutoRefresh) {
      _loadingAsyncContents?.remove(asyncContent);
    }

    var prevRendered = _renderedAsyncContents?[asyncContent];
    if (prevRendered == null) return;

    final renderedElements = _renderedElements;
    if (renderedElements == null) {
      return;
    }

    int? minRenderedElementsIdx;

    for (var e in prevRendered) {
      if (e == null) continue;
      var idx = renderedElements.indexOf(e);
      if (idx >= 0) {
        renderedElements.removeAt(idx);
        if (minRenderedElementsIdx == null || idx < minRenderedElementsIdx) {
          minRenderedElementsIdx = idx;
        }
      }
    }

    var prevElements = prevRendered
        .where((e) => e != null)
        .map((e) => e is UIComponent ? e.content : e)
        .toSet();

    int? maxContentIdx;

    final content = this.content!;
    for (var node in content.childNodes.toList()) {
      if (prevElements.contains(node)) {
        var idx = content.childNodes.indexOf(node);
        if (idx >= 0) {
          content.removeNodeAt(idx);
          if (maxContentIdx == null || idx > maxContentIdx) {
            maxContentIdx = idx;
          }
        }
      }
    }

    var loadedContent = asyncContent.content;

    var renderedList = <Object>[];
    if (maxContentIdx == null || maxContentIdx >= content.childNodes.length) {
      _buildRenderList(loadedContent, renderedList,
          content.childNodes.length - 1, domContext);

      renderedElements.addAll(renderedList);
    } else {
      var tail = content.childNodes.toList().sublist(maxContentIdx).toList();
      for (var e in tail) {
        content.removeChild(e);
      }

      _buildRenderList(loadedContent, renderedList,
          content.childNodes.length - 1, domContext);

      if (tail.isNotEmpty) {
        var renderedComponents = renderedList
            .whereType<UIComponent>()
            .map((e) => e.content)
            .toList();

        tail.removeWhere((e) =>
            renderedList.contains(e) ||
            renderedComponents.contains(e) ||
            content.contains(e));

        content.appendAll(tail);
      }

      minRenderedElementsIdx ??= 0;
      renderedElements.insertAll(minRenderedElementsIdx, renderedList);
    }

    _ensureAllRendered(renderedList);

    try {
      _parseAttributes(content.children.asListViewFixed);
      _parseAttributesPosRender(content.children.asListViewFixed);
    } catch (e, s) {
      UIConsole.error('$this _parseAttributesPosRender(...) error', e, s);
    }

    final renderedAsyncContents = _renderedAsyncContents ??= {};
    renderedAsyncContents[asyncContent] = renderedList;

    _callPosAsyncRender();
  }

  int _addUIAsyncContentToRenderList(UIAsyncContent asyncContent,
      List renderedList, int prevElemIndex, DOMContext<UINode>? domContext) {
    if (!asyncContent.isLoaded ||
        asyncContent.isExpired ||
        asyncContent.hasAutoRefresh) {
      final loadingAsyncContents = _loadingAsyncContents ??= {};
      loadingAsyncContents.add(asyncContent);

      asyncContent.onLoadContent.listen((c) {
        _resolveUIAsyncContentLoaded(asyncContent, domContext);
      }, singletonIdentifier: this);
    }

    if (asyncContent.isExpired) {
      asyncContent.refreshAsync();
    } else if (asyncContent.isWithError) {
      if (asyncContent.hasAutoRefresh) {
        asyncContent.reset();
      }
    }

    var renderIdx = renderedList.length;

    prevElemIndex = _buildRenderList(
        asyncContent.content, renderedList, prevElemIndex, domContext);

    var rendered = renderedList.sublist(renderIdx).toList();

    final renderedAsyncContents = _renderedAsyncContents ??= {};
    renderedAsyncContents[asyncContent] = rendered;

    return prevElemIndex;
  }

  int _addElementToRenderList(
      dynamic value, UINode element, List renderedList, int prevElemIndex) {
    var content = this.content!;

    var idx = content.childNodes.indexOf(element);

    if (idx < 0) {
      content.appendChild(element);
      idx = content.childNodes.indexOf(element);
    } else if (idx < prevElemIndex) {
      element.remove();
      content.appendChild(element);
      idx = content.childNodes.indexOf(element);
    }

    prevElemIndex = idx;
    renderedList.add(value);

    return prevElemIndex;
  }

  void _removeFromContent(Object? value) {
    if (value == null) return;

    if (value.isElement) {
      (value as Element).remove();
    } else if (value is UIComponent) {
      if (value.isRendered) {
        value.content!.remove();
      }
    } else if (value is UIAsyncContent) {
      _removeFromContent(value.loadingContent);
      _removeFromContent(value.content);
    } else if (value is List) {
      for (var val in value) {
        _removeFromContent(val);
      }
    }
  }

  static const handledElementAttributes = <String>[
    'id',
    'navigate',
    'action',
    'onEventKeyPress',
    'onEventClick',
    'data-source',
  ];

  void _parseAttributes(List<Object?> list) {
    if (list.isEmpty) return;

    for (var elem in list.whereElement()) {
      _parseNavigate(elem);
      _parseAction(elem);
      _parseEvents(elem);
      _parseDataSource(elem);

      try {
        _parseAttributes(elem.children.asListViewFixed);
      } catch (e) {
        UIConsole.error('Error parsing attributes for element: $elem', e);
      }
    }
  }

  void _parseAttributesPosRender(List<Object?> list) {
    if (list.isEmpty) return;

    for (var elem in list) {
      if (elem.isHTMLElement) {
        elem = elem as HTMLElement;

        try {
          _parseUILayout(elem);
        } catch (e) {
          UIConsole.error('Error parsing attributes for element: $elem', e);
        }

        try {
          _parseAttributesPosRender(elem.children.asListViewFixed);
        } catch (e) {
          UIConsole.error('Error parsing attributes for element: $elem', e);
        }
      }
    }
  }

  void _parseNavigate(UIElement elem) {
    var navigateRoute = getElementAttribute(elem, 'navigate');

    if (navigateRoute != null && navigateRoute.isNotEmpty) {
      UINavigator.navigateOnClick(elem, navigateRoute);
    }
  }

  void _parseDataSource(UIElement content) {
    var dataSourceCall = getElementAttribute(content, 'data-source');

    if (dataSourceCall != null && dataSourceCall.isNotEmpty) {
      this.dataSourceCall = dataSourceCall;
    }
  }

  DataSourceCall? _dataSourceCall;

  bool get hasDataSource => _dataSourceCall != null;

  DataSource? get dataSource => _dataSourceCall?.dataSource;

  DataSourceCall? get dataSourceCall => _dataSourceCall;

  set dataSourceCall(dynamic daraSourceCall) {
    _dataSourceCall = DataSourceCall.from(daraSourceCall);
  }

  String get dataSourceCallString =>
      _dataSourceCall != null ? _dataSourceCall.toString() : '';

  void connectDataSource() {
    refreshDataSource();
  }

  void refreshDataSource() {
    if (!hasDataSource) return;

    var cachedResponse = _dataSourceCall!.cachedCall();

    if (cachedResponse != null) {
      applyData(cachedResponse);
    } else {
      _dataSourceCall!.call().then((result) {
        applyData(result);
      });
    }
  }

  bool applyData(dynamic data) {
    var changed = setData(data);

    if (changed) {
      ensureRendered(true);
    }

    return changed;
  }

  bool setData(dynamic data) {
    print('SET DATA: $data');
    return false;
  }

  String? _normalizeComponentAttributeName(String? name) {
    if (name == null) return null;
    name = name.toLowerCase().trim();
    if (name.isEmpty) return null;
    return name;
  }

  static final RegExp _valueDelimiterGeneric = RegExp(r'[\s,;]+');

  static List<String>? parseAttributeValueAsStringList(dynamic value,
          [Pattern? delimiter]) =>
      parseStringFromInlineList(value, delimiter ?? _valueDelimiterGeneric);

  static String parseAttributeValueAsString(dynamic value,
      [String? delimiter, Pattern? delimiterPattern]) {
    var list = parseAttributeValueAsStringList(value, delimiterPattern)!;
    if (list.isEmpty) return '';
    delimiter ??= ' ';
    return list.length == 1 ? list.single : list.join(delimiter);
  }

  bool setAttributes(Iterable<DOMAttribute> attributes) {
    if (attributes.isEmpty) return true;

    var anySet = false;
    for (var attr in attributes) {
      var wasSet =
          setAttribute(attr.name, attr.isList ? attr.values : attr.value);
      if (wasSet) {
        anySet = true;
      }
    }
    return anySet;
  }

  bool appendAttributes(Iterable<DOMAttribute> attributes) {
    if (attributes.isEmpty) return false;

    var anySet = false;
    for (var attr in attributes) {
      var wasSet =
          appendAttribute(attr.name, attr.isList ? attr.values : attr.value);
      if (wasSet) {
        anySet = true;
      }
    }
    return anySet;
  }

  String? getAttribute(String? name) {
    name = _normalizeComponentAttributeName(name);
    if (name == null) return null;

    switch (name) {
      case 'style':
        return content!.style.cssText;
      case 'class':
        return content!.classList.value;
      case 'navigate':
        return UINavigator.getNavigateOnClick(content!);
      case 'data-source':
        return dataSourceCallString;
      default:
        return _generator?.getAttribute(this, name);
    }
  }

  static final RegExp _patternStyleDelimiter = RegExp(r'\s*;\s*');

  bool setAttribute(String? name, dynamic value) {
    if (value == null) {
      return clearAttribute(name);
    }

    name = _normalizeComponentAttributeName(name);
    if (name == null) return false;

    switch (name) {
      case 'style':
        {
          var valueCSS =
              parseAttributeValueAsString(value, '; ', _patternStyleDelimiter);
          content!.style.cssText = valueCSS;
          return true;
        }
      case 'class':
        {
          content!.classList.clear();
          content!.classList.addAll(parseAttributeValueAsStringList(value)!);
          return true;
        }
      case 'navigate':
        {
          UINavigator.navigateOnClick(content!, value);
          return true;
        }
      case 'data-source':
        {
          dataSourceCall = parseString(value);
          return true;
        }
      default:
        {
          if (_generator != null) {
            _generator.setAttribute(this, name, value);
            return true;
          } else {
            return false;
          }
        }
    }
  }

  bool appendAttribute(String? name, dynamic value) {
    name = _normalizeComponentAttributeName(name);
    if (name == null) return false;

    switch (name) {
      case 'style':
        {
          appendStyle(value);
          return true;
        }
      case 'class':
        {
          appendClasses(value);
          return true;
        }
      case 'id':
        {
          setID(value);
          return true;
        }
      case 'navigate':
        {
          UINavigator.navigateOnClick(content!, value);
          return true;
        }
      case 'data-source':
        {
          dataSourceCall = parseString(value);
          return true;
        }
      default:
        {
          if (_generator != null) {
            _generator.appendAttribute(this, name, value);
            return true;
          } else {
            return false;
          }
        }
    }
  }

  bool clearAttribute(String? name) {
    name = _normalizeComponentAttributeName(name);
    if (name == null) return false;

    switch (name) {
      case 'style':
        {
          content!.style.cssText = '';
          return true;
        }
      case 'class':
        {
          content!.classList.clear();
          return true;
        }
      case 'navigate':
        {
          UINavigator.clearNavigateOnClick(content!);
          return true;
        }
      case 'data-source':
        {
          dataSourceCall = null;
          return true;
        }
      default:
        {
          if (_generator != null) {
            _generator.clearAttribute(this, name);
            return true;
          } else {
            return false;
          }
        }
    }
  }

  Element? getFieldElementNonTyped(String? fieldName) {
    var elem =
        findInContentChildDeep((e) => getElementFieldName(e) == fieldName);
    return elem;
  }

  E? getFieldElementTyped<E extends HTMLElement>(
      String? fieldName, Web<E> webType) {
    var elem = getFieldElementNonTyped(fieldName);
    return elem.asElementOfNullable<E>(webType);
  }

  Object? getFieldComponent(String? fieldName,
      {bool resolveUIComponents = true}) {
    if (fieldName == null) return null;
    return findChildrenDeep(fieldName, resolveUIComponents: resolveUIComponents)
        ?.value;
  }

  List<UIElement> getFieldElements(String? fieldName) =>
      findChildDeep((e) => getElementFieldName(e) == fieldName);

  UIElement? getFieldElementByValue(String? fieldName, String value,
          {bool resolveUIComponents = true}) =>
      getFieldElements(fieldName).firstWhereOrNull((e) =>
          e.resolveElementValue(resolveUIComponents: resolveUIComponents) ==
          value);

  String? getComponentFieldName(Object obj) {
    if (obj is UIField) {
      return obj.fieldName;
    } else if (obj.isElement) {
      return getElementFieldName(obj as Element);
    } else {
      return null;
    }
  }

  String? getElementFieldName(UIElement element,
      {bool resolveUIComponents = true}) {
    var ret =
        _resolveElementField(element, resolveUIComponents: resolveUIComponents);
    return ret?.key;
  }

  MapEntry<String, Object>? _resolveElementField<V>(UIElement element,
      {bool resolveUIComponents = true}) {
    var fieldName = element.resolveFieldName();
    if (fieldName != null) return fieldName;

    if (resolveUIComponents) {
      var component = _getUIComponentByContent(element);
      if (component != null) {
        if (component is UIField) {
          var field = component as UIField;
          var fieldName = field.fieldName;
          return MapEntry<String, Object>(fieldName, component);
        }
      }
    }

    return null;
  }

  Map<String, UIElement> getFieldsElementsMap(
      {List<String>? fields,
      List<String>? ignoreFields,
      bool resolveUIComponents = true}) {
    fields ??= [];
    ignoreFields ??= [];

    final specificFields = fields.isNotEmpty;

    final fieldsElements = getFieldsElements();

    final map = <String, UIElement>{};

    for (var elem in fieldsElements) {
      var fieldName =
          getElementFieldName(elem, resolveUIComponents: resolveUIComponents)!;

      var include = specificFields ? fields.contains(fieldName) : true;

      if (include && !ignoreFields.contains(fieldName)) {
        if (map.containsKey(fieldName)) {
          var elemValue = parseChildElementValue(map[fieldName],
              allowTextAsValue: false,
              resolveUIComponents: resolveUIComponents);

          if (isEmptyObject(elemValue)) {
            var value = parseChildElementValue(elem,
                allowTextAsValue: false,
                resolveUIComponents: resolveUIComponents);
            if (isNotEmptyObject(value)) {
              map[fieldName] = elem;
            }
          }
        } else {
          map[fieldName] = elem;
        }
      }
    }

    return map;
  }

  /// Alias to [content.querySelector].
  Element? querySelectorNonTyped(String? selectors) {
    if (selectors == null || selectors.isEmpty) return null;
    return content?.querySelector(selectors);
  }

  /// Alias to [content.querySelector].
  E? querySelectorTyped<E extends Element>(String? selectors, Web<E> webType) {
    if (selectors == null || selectors.isEmpty) return null;
    if (webType == Web.Element) {
      // Faster:
      return content?.querySelector(selectors) as E?;
    } else {
      return content?.querySelectorAllTyped<E>(selectors, webType).firstOrNull;
    }
  }

  /// Alias to [content.querySelector].
  Element? selectElementNonTyped(String? selectors) =>
      querySelectorNonTyped(selectors);

  /// Alias to [content.querySelector].
  E? selectElementTyped<E extends UIElement>(
          String? selectors, Web<E> webType) =>
      querySelectorTyped<E>(selectors, webType);

  /// Alias to [content.querySelectorAll].
  List<Element> querySelectorAllNonTyped(String? selectors) {
    if (selectors == null || selectors.isEmpty) return [];
    return content?.querySelectorAll(selectors).toElements() ?? [];
  }

  /// Alias to [content.querySelectorAll].
  List<T> querySelectorAllTyped<T extends UIElement>(
      String? selectors, Web<T> webType) {
    if (selectors == null || selectors.isEmpty) return <T>[];
    return content?.querySelectorAllTyped<T>(selectors, webType) ?? <T>[];
  }

  /// Alias to [content.querySelectorAll].
  List<Element> selectElementsNonTyped(String? selectors) =>
      querySelectorAllNonTyped(selectors);

  /// Alias to [content.querySelectorAll].
  List<T> selectElementsTyped<T extends UIElement>(
          String? selectors, Web<T> webType) =>
      querySelectorAllTyped(selectors, webType);

  /// Alias to [content.querySelectorAll].
  Map<String, String?> selectElementsNonTypedValues(String? selectors) {
    var entries = selectElementsNonTyped(selectors).map((e) {
      var k = e.getAttribute('name')?.trim();
      if (k == null || k.isEmpty) {
        k = e.id.trim();
      }
      return MapEntry(k, e.elementValue);
    });
    return Map.fromEntries(entries);
  }

  /// Alias to [content.querySelectorAll].
  Map<String, String?> selectElementsTypedValues<T extends UIElement>(
      String? selectors, Web<T> webType) {
    var entries = selectElementsTyped<T>(selectors, webType).map((e) {
      var k = e.getAttribute('name')?.trim();
      if (k == null || k.isEmpty) {
        k = e.id.trim();
      }
      return MapEntry(k, e.elementValue);
    });
    return Map.fromEntries(entries);
  }

  bool clearContent() {
    content!.clear();
    return true;
  }

  bool setContentNodes(List<UINode> nodes) {
    content!.clear();
    content!.appendAll(nodes);
    return true;
  }

  bool appendToContent(List<UINode> nodes) {
    content!.appendAll(nodes);
    return true;
  }

  List<UIElement> getFieldsElements() => _getContentChildrenImpl(
      content!.children.asListViewFixed,
      [],
      true,
      (e) => getElementFieldName(e) != null);

  String? parseChildElementValue(UIElement? childElement,
          {UIComponent? childUiComponent,
          bool allowTextAsValue = true,
          bool resolveUIComponents = true}) =>
      childElement?.resolveElementValue(
          parentUIComponent: this,
          uiComponent: childUiComponent,
          allowTextAsValue: allowTextAsValue,
          resolveUIComponents: resolveUIComponents);

  Map<String, String?> getFields(
      {List<String>? fields,
      List<String>? ignoreFields,
      bool resolveUIComponents = true}) {
    var fieldsElementsMap = getFieldsElementsMap(
        fields: fields,
        ignoreFields: ignoreFields,
        resolveUIComponents: resolveUIComponents);

    var entries = fieldsElementsMap.entries.toList();

    var entriesUIComponents = resolveUIComponents
        ? Map.fromEntries(entries
            .map((e) => MapEntry(e.value, findUIComponentByChild(e.value))))
        : {};

    entries.sort((a, b) {
      var aUiComponent = entriesUIComponents[a.value];
      var bUiComponent = entriesUIComponents[b.value];
      var aIsUIComponent = aUiComponent != null;
      var bIsUIComponent = bUiComponent != null;

      if (aIsUIComponent && !bIsUIComponent) {
        return -1;
      } else if (bIsUIComponent && !aIsUIComponent) {
        return 1;
      } else {
        return 0;
      }
    });

    var fieldsValues = <String, String?>{};

    for (var entry in entries) {
      var key = entry.key;
      if (fieldsValues.containsKey(key)) continue;

      var uiComponent = entriesUIComponents[entry.value];

      var value = parseChildElementValue(entry.value,
          childUiComponent: uiComponent,
          resolveUIComponents: resolveUIComponents);

      fieldsValues[key] = value;
    }

    return fieldsValues;
  }

  Map<String, Object?> getFieldsExtended(
      {List<String>? fields, List<String>? ignoreFields}) {
    var fieldsElementsMap =
        getFieldsComponentsMap(fields: fields, ignoreFields: ignoreFields);

    var entries = fieldsElementsMap.entries.toList();
    entries.sort((a, b) {
      var aIsUIComponent = a is UIComponent;
      var bIsUIComponent = b is UIComponent;

      if (aIsUIComponent && !bIsUIComponent) {
        return -1;
      } else if (bIsUIComponent && !aIsUIComponent) {
        return 1;
      } else {
        return 0;
      }
    });

    var fieldsValues = <String, Object?>{};

    for (var entry in entries) {
      var key = entry.key;
      if (fieldsValues.containsKey(key)) continue;
      fieldsValues[key] = entry.value;
    }

    return fieldsValues;
  }

  Map<String, dynamic>? _renderedFieldsValues;

  dynamic getPreviousRenderedFieldValue(String? fieldName) =>
      _renderedFieldsValues != null ? _renderedFieldsValues![fieldName!] : null;

  void setField(String fieldName, dynamic value) {
    var fieldElem = getFieldElementNonTyped(fieldName);
    if (fieldElem == null) return;

    var valueStr = value != null ? '$value' : null;

    _renderedFieldsValues ??= {};
    _renderedFieldsValues![fieldName] = valueStr;

    fieldElem.setValue(valueStr);
  }

  void updateRenderedFieldValue(String fieldName) {
    var fieldElem = getFieldElementNonTyped(fieldName);
    if (fieldElem == null) return;

    var value = parseChildElementValue(fieldElem);

    var renderedFieldsValues = _renderedFieldsValues ??= <String, dynamic>{};
    renderedFieldsValues[fieldName] = value;
  }

  void updateRenderedFieldElementValue(UIElement fieldElem) {
    var fieldName = getElementFieldName(fieldElem);
    if (fieldName == null) return;

    var value = parseChildElementValue(fieldElem);

    var renderedFieldsValues = _renderedFieldsValues ??= <String, dynamic>{};
    renderedFieldsValues[fieldName] = value;
  }

  bool hasEmptyField() => getFieldsElementsMap().isEmpty;

  List<String> getFieldsNames() => getFieldsElementsMap().keys.toList();

  String? getField(String? fieldName, [String? def]) {
    if (fieldName == null) return def;
    var field = getFieldExtended(fieldName);
    return field?.toString() ?? def;
  }

  V? getFieldExtended<V>(String? fieldName, [V? def]) {
    if (fieldName == null) return def;
    var fieldComponent = getFieldComponent(fieldName);
    if (fieldComponent == null) return def;

    if (fieldComponent is UIField) {
      return fieldComponent.getFieldValue() as V? ?? def;
    } else if (fieldComponent is UIComponent) {
      var val = parseChildElementValue(fieldComponent.content,
          childUiComponent: fieldComponent);
      return val as V? ?? def;
    } else if (fieldComponent.isElement) {
      var val = parseChildElementValue(fieldComponent as Element);
      return val as V? ?? def;
    } else {
      return fieldComponent.toString() as V? ?? def;
    }
  }

  T? getFieldAs<T>(String? fieldName, [T? def]) {
    var value = getField(fieldName);
    if (value == null) return null;

    if (T == String) {
      return value as T;
    } else if (T == int) {
      return parseInt(value, def as int?) as T?;
    } else if (T == double) {
      return parseDouble(value, def as double?) as T?;
    } else if (T == num) {
      return parseNum(value, def as num?) as T?;
    } else if (T == bool) {
      return parseBool(value, def as bool?) as T?;
    } else if (T == Decimal) {
      return Decimal.parse(value) as T? ?? def;
    } else if (T == DynamicInt) {
      return DynamicInt.parse(value) as T? ?? def;
    } else if (T == DynamicNumber) {
      return DynamicNumber.parse(value) as T? ?? def;
    } else {
      return null;
    }
  }

  static T Function(String s) _parserFor<T>() {
    var parser = _parserForImpl<T>();
    return (s) => parser(s) as T;
  }

  static T? Function(String s) _parserForNullable<T>() {
    var parser = _parserForImpl<T>();
    return (s) => parser(s) as T?;
  }

  static Object? Function(String s) _parserForImpl<T>() {
    if (T == int) {
      return parseInt;
    } else if (T == double) {
      return parseDouble;
    } else if (T == num) {
      return parseNum;
    } else if (T == bool) {
      return parseBool;
    } else {
      return (s) => s;
    }
  }

  List<MapEntry<K, V?>> getFieldsGroupEntriesByPrefix<K, V>(
    String groupPrefix, {
    Map<String, String?>? fields,
    String keyDelimiter = '_',
    String Function(String key)? keyPart,
    K Function(String key)? keyAs,
    V? Function(String key)? valueAs,
    bool Function(K key, V? value)? filter,
  }) {
    keyPart ??= (k) => k.split(keyDelimiter).last;
    keyAs ??= _parserFor<K>();
    valueAs ??= _parserForNullable<V>();

    fields ??= getFields();

    var entries =
        fields.entries.where((e) => e.key.startsWith(groupPrefix)).map((e) {
      var key = keyPart!(e.key);
      var value = e.value ?? '';
      var k = keyAs!(key);
      var v = valueAs!(value);
      return k != null ? MapEntry(k, v) : null;
    }).nonNulls;

    if (filter != null) {
      entries = entries.where((e) => filter(e.key, e.value));
    }

    return entries.toList();
  }

  Map<K, List<V>> getFieldsGroupListByPrefix<K, V>(
    String groupPrefix, {
    Map<String, String?>? fields,
    String keyDelimiter = '_',
    String Function(String key)? keyPart,
    K Function(String key)? keyAs,
    V? Function(String key)? valueAs,
    bool Function(K key, V? value)? filter,
  }) {
    var entries = getFieldsGroupEntriesByPrefix<K, V>(groupPrefix,
        fields: fields,
        keyDelimiter: keyDelimiter,
        keyPart: keyPart,
        keyAs: keyAs,
        valueAs: valueAs,
        filter: filter);

    var groups = entries.groupListsBy((e) => e.key);

    var map = groups.map(
        (k, l) => MapEntry(k, l.map((e) => e.value).whereType<V>().toList()));

    return map;
  }

  List<K> getFieldsGroupKeysByPrefix<K>(
    String groupPrefix, {
    Map<String, String?>? fields,
    String keyDelimiter = '_',
    String Function(String key)? keyPart,
    K Function(String key)? keyAs,
    bool Function(K key, Object? value)? filter,
  }) =>
      getFieldsGroupEntriesByPrefix(groupPrefix,
              fields: fields,
              keyDelimiter: keyDelimiter,
              keyPart: keyPart,
              keyAs: keyAs,
              filter: filter)
          .map((e) => e.key)
          .toSet()
          .toList();

  List<V> getFieldsGroupValuesByPrefix<V>(
    String groupPrefix, {
    Map<String, String?>? fields,
    String keyDelimiter = '_',
    String Function(String key)? keyPart,
    V? Function(String key)? valueAs,
    bool Function(Object key, V? value)? filter,
  }) =>
      getFieldsGroupEntriesByPrefix(groupPrefix,
              fields: fields,
              keyDelimiter: keyDelimiter,
              keyPart: keyPart,
              valueAs: valueAs,
              filter: filter)
          .map((e) => e.value)
          .whereType<V>()
          .toList();

  Map<K, V?> getFieldsGroupByPrefix<K, V>(
    String groupPrefix, {
    Map<String, String?>? fields,
    String keyDelimiter = '_',
    String Function(String key)? keyPart,
    K Function(String key)? keyAs,
    V? Function(String key)? valueAs,
    bool Function(K key, V? value)? filter,
  }) {
    var entries = getFieldsGroupEntriesByPrefix<K, V>(groupPrefix,
        fields: fields,
        keyDelimiter: keyDelimiter,
        keyPart: keyPart,
        keyAs: keyAs,
        valueAs: valueAs,
        filter: filter);

    var map = Map.fromEntries(entries);
    return map;
  }

  Map<K, bool> getFieldsGroupChecks<K>(
    String groupPrefix, {
    Map<String, String?>? fields,
    String keyDelimiter = '_',
    String Function(String key)? keyPart,
    K Function(String key)? keyAs,
    bool Function(K key, bool? value)? filter,
  }) =>
      getFieldsGroupByPrefix<K, bool?>(
        groupPrefix,
        fields: fields,
        keyDelimiter: keyDelimiter,
        keyPart: keyPart,
        keyAs: keyAs,
        valueAs: (v) => parseBool(v, false)!,
        filter: filter,
      ).map((k, v) => MapEntry(k, v!));

  List<K> getFieldsGroupCheckedKeys<K>(
    String groupPrefix, {
    Map<String, String?>? fields,
    String keyDelimiter = '_',
    String Function(String key)? keyPart,
    K Function(String key)? keyAs,
  }) =>
      getFieldsGroupChecks<K>(
        groupPrefix,
        fields: fields,
        keyDelimiter: keyDelimiter,
        keyPart: keyPart,
        keyAs: keyAs,
        filter: (k, v) => v == true,
      ).keys.toList();

  bool isEmptyField(String? fieldName) {
    if (fieldName == null) return false;
    var val = getFieldExtended(fieldName);
    return isEmptyValue(val);
  }

  List<String> getEmptyFields() {
    var fields = getFields();
    fields.removeWhere((k, v) => !isEmptyValue(v));
    return fields.keys.toList();
  }

  bool focusField(String? fieldName) {
    if (fieldName == null) return false;

    var component = getFieldComponent(fieldName);

    if (component.asJSAny.isA<HTMLElement>()) {
      (component as HTMLElement).focus();
      return true;
    } else if (component is UIComponent) {
      var input = findInContentChildDeep((e) => e.isTextInput);
      if (input != null) {
        return input.focus();
      }

      var content = component.content;
      if (content != null) {
        content.focus();
        return true;
      } else {
        return false;
      }
    }

    return false;
  }

  int forEachFieldElement(ForEachElement f) {
    var count = 0;

    for (var elem in getFieldsElements()) {
      f(elem);
      count++;
    }

    return count;
  }

  int forEachFieldComponent(ForEachComponent f) {
    var count = 0;

    for (var e in getFieldsComponents()) {
      f(e);
      count++;
    }

    return count;
  }

  int forEachEmptyFieldElement(ForEachElement f) {
    var count = 0;

    var list = getEmptyFields();
    for (var fieldName in list) {
      var elem = getFieldElementNonTyped(fieldName);
      if (elem != null) {
        f(elem);
        count++;
      }
    }

    return count;
  }

  int forEachEmptyFieldComponent(ForEachComponent f) {
    var count = 0;

    var list = getEmptyFields();

    for (var fieldName in list) {
      var elem = getFieldComponent(fieldName);
      if (elem != null) {
        f(elem);
        count++;
      }
    }

    return count;
  }

  void _parseAction(UIElement elem) {
    var actionValue = getElementAttribute(elem, 'action');

    if (actionValue != null && actionValue.isNotEmpty) {
      addTrackedEventListener(
          elem, EventType.click, (e) => action(actionValue));
    }
  }

  void action(String action) {
    UIConsole.log('action: $action');
  }

  void _parseUILayout(HTMLElement elem) {
    var uiLayout = getElementAttribute(elem, 'uiLayout');

    if (uiLayout != null) {
      UILayout(this, elem, uiLayout);
    }
  }

  void _parseEvents(UIElement elem) {
    _parseOnEventKeyPress(elem);
    _parseOnEventClick(elem);
  }

  void _parseOnEventKeyPress(UIElement elem) {
    var keypress = getElementAttribute(elem, 'onEventKeyPress');

    if (keypress != null && keypress.isNotEmpty) {
      var parts = keypress.split(':');
      var key = parts[0].trim();
      var actionType = parts[1];

      if (key == '*') {
        addTrackedEventListener(
            elem, EventType.keyPress, (e) => action(actionType));
      } else {
        addTrackedEventListener(elem, EventType.keyPress, (e) {
          if (equalsIgnoreAsciiCase(e.key, key) ||
              equalsIgnoreAsciiCase(e.keyCodeSafe.toString(), key)) {
            action(actionType);
          }
        });
      }
    }
  }

  void _parseOnEventClick(UIElement elem) {
    var click = getElementAttribute(elem, 'onEventClick');

    if (click != null && click.isNotEmpty) {
      addTrackedEventListener(elem, EventType.click, (e) => action(click));
    }
  }

  int _disposeCount = 0;

  int get disposeCount => _disposeCount;

  bool _disposed = false;

  /// Whether this instance has been disposed.
  ///
  /// A disposed instance should no longer be used.
  bool get isDisposed => _disposed;

  /// Disposes this instance and releases all associated resources.
  ///
  /// Marks the object as disposed, clears cached rendering state,
  /// and removes all registered event listeners.
  void dispose() {
    ++_disposeCount;
    _disposed = true;

    if (!preserveRender) {
      cancelRegisteredEventListeners();

      final domTreeMap = _domTreeMap;
      if (domTreeMap != null) {
        if (!_subComponent) {
          domTreeMap.dispose();
        }
        _domTreeMap = null;
      }

      _renderedElements = null;
      _renderedFieldsValues = null;
    }
  }

  void _recycle() {
    if (!_disposed) return;
    _disposed = false;

    var content = _content;
    if (content != null) {
      _contentsUIComponents[content] = WeakReference(this);
    } else {
      _setContent(createContentElement(true));
    }

    // Ensure instantiated:
    domTreeMap;
  }

  /// Purges all global UI state and resources.
  ///
  /// Clears globally managed components, mappings, and caches.
  static Future<void> purgeGlobals() async {
    _asyncRenderingZoneComponent.purge();
    await yeld();

    DSX.purge();
    await yeld();
  }
}
